Assignment-2
Topic-1
a)  Write a program using arrays to read & print a polynomial.

    Read Polynomial:
        Input(s):
            1.  Number of terms a polynomial will have
        Output(s):
            1.  Polynomial expression
        Complexity:
            Best case -> O(n)
            Average case -> O(n)
            Worst case -> O(n)
        Algorithm:
            readPolynomial(numberOfTerms){
                for(i = 1 to numberOfTerms){
                    read(operation[i].co_officient) //This line indicate user input
                    if(i > 0 & operation[i - 1].operator = '-'){
                        operation[i].co_officient = -operation[i].co_officient
                        operation[i - 1].operator = '+'
                    }
                    read(operation.power) //This line indicate user input
                    do {
                        if(i + 1 <= numberOfTerms){
                            read(operation.operator)
                        } else {
                            operation.operator = '\0'
                        }
                    } while(operation.operator != '+' & operation.operator != '-)
                }
                return operation
            }
    Sort Polynomial:
        Input(s):
            1.  Polynomial expression
            2.  Number of terms a polynomial have
        Output(s):
            1.  Sorted polynomial expression
        Complexity:
            Best case -> O(n + nlogn) ~ O(nlogn)
            Average case -> O(n + (n ^ 2)) ~ O(n ^ 2)
            Worst case -> O(n + (n ^ 2)) ~ O(n ^ 2)
        Algorithm:
            quicksort(operation, low, high, numberOfTerms){
                if(low < high){
                    pivotIndex = high
                    i = low
                    j = i
                    pivotTermPower = operation[pivotIndex].power
                    while(i < high){
                        if(operation[i].power >= pivotTermPower){
                            if(operation[i].power > pivotTermPower){
                                swap(operation[i], operation[j])
                                j = j + 1
                            } else {
                                if(i > 0){
                                    operation[i - 1].operator = operation[i].operator
                                }
                                operation[pivotIndex].co_officient = operation[pivotIndex].co_officient + operation[i].co_officient
                                k = i
                                while(k < numberOfTerms){
                                    operation[k] = operation[k + 1]
                                    k = k + 1
                                }
                                pivotIndex = pivotIndex - 1
                                high = high - 1
                                numberOfTerms = numberOfTerms - 1
                                i = i - 1
                            }
                        }
                        i = i + 1
                    }
                    if(operation[j].power < operation[pivotIndex].power){
                        swap(operation[j].operator, operation[pivotIndex].operator)
                        swap(operation[j], operation[pivotIndex])
                    }
                    numberOfTerms = quicksort(operation, low, j - 1, numberOfTerms)
                    numberOfTerms = quicksort(operation, j + 1, high, numberOfTerms)
                }
                return numberOfTerms
            }
            sortPolynomial(operation, numberOfTerms){
                numberOfTerms = quicksort(operation, 0, numberOfTerms, numberOfTerms)
                for(i = 1 to numberOfTerms){
                    if(operation[i].co_officient = 0){
                        if(i + 1 <= numberOfTerms){
                            operation[i] = operation[i + 1]
                            numberOfTerms = numberOfTerms - 1
                        }
                    }
                }
            }

b)  Write a program to add & multiply two polynomials.

    Addition Of Polynomials:
        Input(s):
            1.  Polynomial expression 1
            2.  Number of terms polynomial 1 have
            3.  Polynomial expression 2
            4.  Number of terms polynomial 2 have
            5.  Number of terms resultant polynomial will have
        Output(s):
            1.  Addition of two polynomial expressions
        Complexity:
            Best case -> O(n + m)
            Average case -> O(n + m)
            Worst case -> O(n + m)
        Algorithm:
            addition(operation1, numberOfTerms1, operation2, numberOfTerms2, numberOfTerms) {
                if(numberOfTerms1 = 0){
                    operation = operation2
                    numberOfTerms = numberOfTerms2
                } else {
                    if(numberOfTerms2 = 0){
                        operation = operation1
                        numberOfTerms = numberOfTerms1
                    } else {
                        i = 1
                        j = 1
                        k = 1
                        do {
                            if(operation1[i].power = operation2[j].power){
                                operation[k].co_officient = operation1[i].co_officient + operation2[j].co_officient
                                operation[k].power = operation1[i].power
                                operation[k].operator = '+'
                                i = i + 1
                                j = j + 1
                            } else {
                                if(operation1[i].power > operation2[j].power){
                                    operation[k] = operation1[i]
                                    i = i + 1
                                } else {
                                    operation[k] = operation2[j]
                                    j = j + 1
                                }
                            }
                            k = k + 1
                        } while(i <= numberOfTerms1 & j <= numberOfTerms2)
                        while(i <= numberOfTerms1){
                            operation[k] = operation[i]
                            i = i + 1
                            k = k + 1
                        }
                        while(j <= numberOfTerms2){
                            operation[k] = operation[j]
                            j = j + 1
                            k = k + 1
                        }
                        operation[k - 1] = '\0'
                        numberOfTerms = k - 1
                    }
                }
                return operation
            }
    Multiplication Of Polynomials:
        Input(s):
            1.  Polynomial expression 1
            2.  Number of terms polynomial 1 have
            3.  Polynomial expression 2
            4.  Number of terms polynomial 2 have
            5.  Number of terms resultant polynomial will have
        Output(s):
            1.  Multiplication of two polynomial expressions
        Complexity:
            Best case -> O(n * m)
            Average case -> O(n * m)
            Worst case -> O(n * m)
        Algorithm:
            multiplication(operation1, numberOfTerms1, operation2, numberOfTerms2, numberOfTerms){
                numberOfTerms = numberOfTerms1 * numberOfTerms2
                i = 1
                k = 1
                while(i < numberOfTerms1){
                    j = 1
                    while(j < numberOfTerms2){
                        operation[k].co_officient = operation[i].co_officient * operation[j].co_officient
                        operation[k].power = operation[i].power + operation[j].power
                        operation[k].operator = '+'
                        k = k + 1
                        j = j + 1
                    }
                    i = i + 1
                }
                operation[k - 1].operator = '\0'
                sortPolynomial(operation, numberOfTerms)
                return operation
            }

Topic-2
a)  Write a program using linked list with header node & sentinel value to read & print a polynomial.

    Read Polynomial:
        Input(s):
            1.  Head pointer of a linked list
        Output(s):
            1.  Polynomial expression
        Complexity:
            Best case -> O(n)
            Average case -> O(n)
            Worst case -> O(n)
        Algorithm:
            readPolynomial(operationHead){
                for(i = 1 to numberOfTerms){
                    read(operation -> co_officient) //This line indicate user input
                    if(prevOperation != operationHead & prevOperation -> operator = '-'){
                        operation[i].co_officient = -operation[i].co_officient
                        prevOperation -> operator = '-'
                    }
                    read(operation -> power) //This line indicate user input
                    do {
                        if(i + 1 <= numberOfTerms){
                            read(operation -> operator)
                        } else {
                            operation -> operator = '\0'
                        }
                    } while(operation -> operator != '+' & operation -> operator != '-')
                    operation -> nextOperation = NULL
                    prevOperation -> nextOperation = operation
                    prevOperation = operation
                }
            }
    Sort Polynomial:
        Input(s):
            1.  Head pointer of a linked list
        Output(s):
            1.  Sorted polynomial expression
        Complexity:
            Best case -> O(n ^ 2)
            Average case -> O(n ^ 2)
            Worst case -> O(n ^ 2)
        Algorithm:
            sortPolynomial(operationHead){
                unsortedOperationTraverser = operationHead -> nextOperation
                if(unsortedOperationTraverser != NULL){
                    unsortedOperation = unsortedOperationTraverser -> nextOperation
                    while(unsortedOperation != NULL){
                        sortedOperationTraverser = operationHead
                        while(sortedOperationTraverser -> nextOperation -> power > unsortedOperation -> power && sortedOperationTraverser -> nextOperation != unsortedOperation) {
                            sortedOperationTraverser = sortedOperationTraverser -> nextOperation;
                        }
                        if(sortedOperationTraverser -> nextOperation -> power <= unsortedOperation -> power && sortedOperationTraverser -> nextOperation != unsortedOperation){
                            if(sortedOperationTraverser -> nextOperation -> power < unsortedOperation -> power){
                                unsortedOperationTraverser -> nextOperation = unsortedOperation -> nextOperation
                                unsortedOperation -> nextOperation = sortedOperationTraverser -> nextOperation
                                sortedOperationTraverser -> nextOperation = unsortedOperation
                                unsortedOperation -> operator = '+'
                            } else {
                                unsortedOperationTraverser -> nextOperation = unsortedOperation -> nextOperation
                                unsortedOperation -> nextOperation = NULL
                                sortedOperationTraverser -> nextOperation -> co_officient = unsortedOperation -> co_officient + sortedOperationTraverser -> nextOperation -> co_officient
                                free(unsortedOperation)
                                if(sortedOperationTraverser -> nextOperation -> co_officient == 0){
                                    sortedOperationTraverser -> nextOperation = sortedOperationTraverser -> nextOperation -> nextOperation
                                    free(sortedOperationTraverser -> nextOperation)
                                }
                            }
                        } else {
                            unsortedOperationTraverser = unsortedOperationTraverser -> nextOperation
                        }
                        unsortedOperation = unsortedOperationTraverser -> nextOperation
                    }
                    unsortedOperationTraverser -> nextOperation = NULL
                }
            }

b)  Write another program to insert & delete a term of polynomial.

    Add New Term:
        Input(s):
            1.  Head pointer of a linked list
        Output(s):
            1.  Updated & sorted polynomial expression
        Complexity:
            Best case -> O(n + (n ^ 2)) ~ O(n ^ 2)
            Average case -> O(n + (n ^ 2)) ~ O(n ^ 2)
            Worst case -> O(n + (n ^ 2)) ~ O(n ^ 2)
        Algorithm:
            sortPolynomial(operationHead){
                unsortedOperationTraverser = operationHead -> nextOperation
                if(unsortedOperationTraverser != NULL){
                    unsortedOperation = unsortedOperationTraverser -> nextOperation
                    while(unsortedOperation != NULL){
                        sortedOperationTraverser = operationHead
                        while(sortedOperationTraverser -> nextOperation -> power > unsortedOperation -> power && sortedOperationTraverser -> nextOperation != unsortedOperation) {
                            sortedOperationTraverser = sortedOperationTraverser -> nextOperation
                        }
                        if(sortedOperationTraverser -> nextOperation -> power <= unsortedOperation -> power && sortedOperationTraverser -> nextOperation != unsortedOperation){
                            if(sortedOperationTraverser -> nextOperation -> power < unsortedOperation -> power){
                                unsortedOperationTraverser -> nextOperation = unsortedOperation -> nextOperation
                                unsortedOperation -> nextOperation = sortedOperationTraverser -> nextOperation
                                sortedOperationTraverser -> nextOperation = unsortedOperation
                                unsortedOperation -> operator = '+'
                            } else {
                                unsortedOperationTraverser -> nextOperation = unsortedOperation -> nextOperation
                                unsortedOperation -> nextOperation = NULL
                                sortedOperationTraverser -> nextOperation -> co_officient = unsortedOperation -> co_officient + sortedOperationTraverser -> nextOperation -> co_officient
                                free(unsortedOperation)
                                if(sortedOperationTraverser -> nextOperation -> co_officient == 0){
                                    sortedOperationTraverser -> nextOperation = sortedOperationTraverser -> nextOperation -> nextOperation
                                    free(sortedOperationTraverser -> nextOperation)
                                }
                            }
                        } else {
                            unsortedOperationTraverser = unsortedOperationTraverser -> nextOperation
                        }
                        unsortedOperation = unsortedOperationTraverser -> nextOperation
                    }
                    unsortedOperationTraverser -> nextOperation = NULL
                }
            }
            appendPolynomial(operationHead){
                flag = 0
                inAppended = 0
                prevOperation = operationHead
                operation = operationHead -> nextOperation
                while(operation != NULL){
                    prevOperation = operation
                    operation = operation -> nextOperation
                }
                do {
                    read(operation -> co_officient) //This line indicate user input
                    if(operation -> co_officient != 0){
                        if(prevOperation != operationHead && prevOperation -> operator == '-'){
                            operation -> co_officient = -(operation -> co_officient)
                            prevOperation -> operator = '+'
                        }
                        read(operation -> power) //This line indicate user input
                        do {
                            read(flag) //This line indicate user input
                        } while(flag != 0 && flag != 1)
                        if(flag == 1){
                            do {
                                read(operation -> operator) //This line indicate user input
                            } while(operation -> operator != '+' && operation -> operator != '-')
                        } else {
                            operation -> operator = '\0'
                        }
                        prevOperation -> nextOperation = operation
                        prevOperation = operation
                        isAppended = 1
                    } else {
                        flag = 0
                        prevOperation -> operator = '\0'
                    }
                } while(flag == 1)
                if(isAppended == 1){
                   sortPolynomial(operationHead)
                }
            }
    Delete Existing Term:
        Input(s):
            1.  Head pointer of a linked list
        Output(s):
            1.  Updated polynomial expression
        Complexity:
            Best case -> O(n)
            Average case -> O(n)
            Worst case -> O(n)
        Algorithm:
            deletePolynomialTerm(operationHead){
                flag = 0
                isAppended = 0
                if(operationHead -> nextOperation != NULL){
                    read(co_officient) //This line indicate user input
                    if(co_officient != 0){
                        read(power) //This line indicate user input
                        prevOperation = operationHead
                        operation = operationHead -> nextOperation
                        while(operation != NULL && (operation -> power != power || operation -> co_officient != co_officient)){
                            prevOperation = operation
                            operation = operation -> nextOperation
                        }
                        if(operation != NULL){
                            prevOperation -> nextOperation = operation -> nextOperation
                            operation -> nextOperation = NULL
                            free(operation)
                        } else {
                            //print that the given term not found
                        }
                    } else {
                        //print 0 is invalid co-officient
                    }
                } else {
                    //print there is nothing to delete
                }
            }

c)  Write a program to add & multiply two polynomials.

    Addition Of Polynomials:
        Input(s):
            1.  Head pointer of a linked list 1
            2.  Head pointer of a linked list 2
            3.  Head pointer of a linked list 3
        Output(s):
            1.  Addition of polynomial1 & polynimial2 in linked list 3
        Complexity:
            Best case -> O(n + m)
            Average case -> O(n + m)
            Worst case -> O(n + m)
        Algorithm:
            addition(operationHead1, operationHead2, operationHead3){
                currOperation1 = operationHead1 -> nextOperation
                currOperation2 = operationHead2 -> nextOperation
                currOperation3 = operationHead3
                while(currOperation1 != NULL && currOperation2 != NULL){
                    if(currOperation1 -> power > currOperation2 -> power){
                        operation -> co_officient = currOperation1 -> co_officient
                        operation -> power = currOperation1 -> power
                        operation -> operator = currOperation1 -> operator
                        operation -> nextOperation = NULL
                        currOperation1 = currOperation1 -> nextOperation
                    } else if(currOperation1 -> power < currOperation2 -> power){
                        operation -> co_officient = currOperation2 -> co_officient
                        operation -> power = currOperation2 -> power
                        operation -> operator = currOperation2 -> operator
                        operation -> nextOperation = NULL
                        currOperation2 = currOperation2 -> nextOperation
                    } else {
                        operation -> co_officient = (currOperation1 -> co_officient) + (currOperation2 -> co_officient)
                        operation -> power = currOperation1 -> power
                        operation -> operator = currOperation1 -> operator
                        operation -> nextOperation = NULL
                        currOperation1 = currOperation1 -> nextOperation
                        currOperation2 = currOperation2 -> nextOperation
                    }
                    currOperation3 -> nextOperation = operation
                    currOperation3 = operation
                }
                while(currOperation1 != NULL){
                    operation -> co_officient = currOperation1 -> co_officient
                    operation -> power = currOperation1 -> power
                    operation -> operator = currOperation1 -> operator
                    operation -> nextOperation = NULL
                    currOperation1 = currOperation1 -> nextOperation
                    currOperation3 -> nextOperation = operation
                    currOperation3 = operation
                }
                while(currOperation2 != NULL){
                    operation -> co_officient = currOperation2 -> co_officient
                    operation -> power = currOperation2 -> power
                    operation -> operator = currOperation2 -> operator
                    operation -> nextOperation = NULL
                    currOperation2 = currOperation2 -> nextOperation
                    currOperation3 -> nextOperation = operation
                    currOperation3 = operation
                }
                currOperation3 -> operator = '\0'
            }
    Multiplication Of Polynomials:
        Input(s):
            1.  Head pointer of a linked list 1
            2.  Head pointer of a linked list 2
            3.  Head pointer of a linked list 4
        Output(s):
            1.  Multiplication of polynomial1 & polynimial2 in linked list 4
        Complexity:
            Best case -> O((n * m) + (n ^ 2))
            Average case -> O((n * m) + (n ^ 2))
            Worst case -> O((n * m) + (n ^ 2))
        Algorithm:
            sortPolynomial(operationHead){
                unsortedOperationTraverser = operationHead -> nextOperation
                if(unsortedOperationTraverser != NULL){
                    unsortedOperation = unsortedOperationTraverser -> nextOperation
                    while(unsortedOperation != NULL){
                        sortedOperationTraverser = operationHead
                        while(sortedOperationTraverser -> nextOperation -> power > unsortedOperation -> power && sortedOperationTraverser -> nextOperation != unsortedOperation) {
                            sortedOperationTraverser = sortedOperationTraverser -> nextOperation
                        }
                        if(sortedOperationTraverser -> nextOperation -> power <= unsortedOperation -> power && sortedOperationTraverser -> nextOperation != unsortedOperation){
                            if(sortedOperationTraverser -> nextOperation -> power < unsortedOperation -> power){
                                unsortedOperationTraverser -> nextOperation = unsortedOperation -> nextOperation
                                unsortedOperation -> nextOperation = sortedOperationTraverser -> nextOperation
                                sortedOperationTraverser -> nextOperation = unsortedOperation
                                unsortedOperation -> operator = '+'
                            } else {
                                unsortedOperationTraverser -> nextOperation = unsortedOperation -> nextOperation
                                unsortedOperation -> nextOperation = NULL
                                sortedOperationTraverser -> nextOperation -> co_officient = unsortedOperation -> co_officient + sortedOperationTraverser -> nextOperation -> co_officient
                                free(unsortedOperation)
                                if(sortedOperationTraverser -> nextOperation -> co_officient == 0){
                                    sortedOperationTraverser -> nextOperation = sortedOperationTraverser -> nextOperation -> nextOperation
                                    free(sortedOperationTraverser -> nextOperation)
                                }
                            }
                        } else {
                            unsortedOperationTraverser = unsortedOperationTraverser -> nextOperation
                        }
                        unsortedOperation = unsortedOperationTraverser -> nextOperation
                    }
                    unsortedOperationTraverser -> nextOperation = NULL
                }
            }
            multiplication(operationHead1, operationHead2, operationHead4){
                currOperation1 = operationHead1 -> nextOperation
                currOperation3 = operationHead4
                while(currOperation1 != NULL){
                    currOperation2 = operationHead2 -> nextOperation
                    while(currOperation2 != NULL){
                        operation -> co_officient = (currOperation1 -> co_officient) * (currOperation2 -> co_officient)
                        operation -> power = (currOperation1 -> power) + (currOperation2 -> power)
                        operation -> operator = currOperation1 -> operator
                        operation -> nextOperation = NULL
                        currOperation2 = currOperation2 -> nextOperation
                        currOperation3 -> nextOperation = operation
                        currOperation3 = operation
                    }
                    currOperation1 = currOperation1 -> nextOperation
                }
                currOperation3 -> operator = '\0'
                sortPolynomial(operationHead4)
            }

Topic-4
Write a program to evaluate an arithmatic expression using binary tree

    Read Arithmatic Expression:
        Input(s):
            1.  Take inputs from user
        Output(s):
            1.  Binary tree with arithmatic expression
        Complexity:
            Best case -> O(n)
            Average case -> O(n)
            Worst case -> O(n)
        Algorithm:
            readArithmaticExpression(){
                flag = 0
                read(numberOfTerms) //This line indicate user input
                for(i = 1 to numberOfTerms){
                    read(operand) //This line indicate user input
                    if(i + 1 < numberOfTerms){
                        do {
                            read(operator) //This line indicate user input
                        } while(operator != '+' && operator != '-' && operator != '*' && operator != '/')
                        expression -> operator = operator
                        expression -> rightSubTree = NULL
                        expression -> isRightSubTree = 0
                        if(i > 0){
                            prevOperator = prevExpression -> operator
                            switch(prevOperator){
                                case '+':   
                                case '-':   traverser = prevExpression
                                            while(traverser -> isRightSubTree == 1 && (traverser -> rightSubTree -> operator == '+' || traverser -> rightSubTree -> operator == '-')){
                                                traverser = traverser -> rightSubTree
                                            }
                                            if(operator == '+' || operator == '-'){
                                                if(traverser -> operator == '+' && traverser -> isLeftSubTree == 1){
                                                    if(traverser -> isRightSubTree == 0){
                                                        expression -> leftOperand = operand
                                                        expression -> isLeftSubTree = 0
                                                    } else {
                                                        expression -> leftSubTree = traverser -> rightSubTree
                                                        expression -> isLeftSubTree = 1
                                                        expression -> rightOperand = operand
                                                        expression -> isRightSubTree = 0
                                                    }
                                                    traverser -> rightSubTree = expression
                                                    traverser -> isRightSubTree = 1
                                                } else {
                                                    if(traverser -> isRightSubTree == 0){
                                                        traverser -> rightOperand = operand
                                                        traverser -> isRightSubTree = 0
                                                    } else {
                                                        traverser -> rightSubTree -> rightOperand = operand
                                                        traverser -> rightSubTree -> isRightSubTree = 0
                                                    }
                                                    expression -> leftSubTree = prevExpression
                                                    expression -> isLeftSubTree = 1
                                                    * rootNode = expression
                                                    flag = 0
                                                }
                                            } else {
                                                if(traverser -> isRightSubTree == 0){
                                                    expression -> leftOperand = operand
                                                    expression -> isLeftSubTree = 0
                                                    traverser -> rightSubTree = expression
                                                    traverser -> isRightSubTree = 1
                                                } else {
                                                    expression -> leftSubTree = traverser -> rightSubTree
                                                    expression -> isLeftSubTree = 1
                                                    traverser -> rightSubTree -> rightOperand = operand
                                                    traverser -> rightSubTree -> isRightSubTree = 0
                                                    traverser -> rightSubTree = expression
                                                }
                                                flag = 1
                                            }
                                            break
                                case '*':
                                case '/':   prevExpression -> rightOperand = operand
                                            prevExpression -> isRightSubTree = 0
                                            expression -> leftSubTree = prevExpression
                                            expression -> isLeftSubTree = 1
                                            * rootNode = expression
                                            break
                        }
                    } else {
                        expression -> leftOperand = operand
                        expression -> isLeftSubTree = 0
                        * rootNode = expression
                    }
                    prevExpression = * rootNode
                } else {
                    traverser = prevExpression
                    while(traverser -> isRightSubTree == 1 && (traverser -> rightSubTree -> operator == '+' || traverser -> rightSubTree -> operator == '-')){
                        traverser = traverser -> rightSubTree
                    }
                    if(traverser -> isRightSubTree == 0){
                        traverser -> rightOperand = operand
                        traverser -> isRightSubTree = 0
                    } else {
                        traverser -> rightSubTree -> rightOperand = operand
                        traverser -> rightSubTree -> isRightSubTree = 0
                    }
                }
            }
        }
    Inorder traversal:
        Input(s):
            1.  Parent of sub-tree
        Output(s):
            1.  Inorder traversal of binary tree
        Complexity:
            Best case -> O(logn)
            Average case -> O(logn)
            Worst case -> O(n)
        Algorithm:
            inorderTraversal(parent){
                if(parent -> isLeftSubTree == 1){
                    inorderTraversal(parent -> leftSubTree)
                } else {
                    //print parent -> leftOperand
                }
                //print parent -> operator
                if(parent -> isRightSubTree == 1){
                    inorderTraversal(parent -> rightSubTree)
                } else {
                    //print parent -> rightOperand
                }
            }
    Postorder Traversal:
        Input(s):
            1.  Parent of sub-tree
        Output(s):
            1.  Postorder traversal of binary tree
        Complexity:
            Best case -> O(logn)
            Average case -> O(logn)
            Worst case -> O(n)
        Algorithm:
            postorderTraversal(parent){
                leftOperand = 0
                rightOperand = 0
                if(parent -> isLeftSubTree == 1){
                    leftOperand = postorderTraversal(parent -> leftSubTree)
                } else {
                    leftOperand = parent -> leftOperand
                }
                if(parent -> isRightSubTree == 1){
                    rightOperand = postorderTraversal(parent -> rightSubTree)
                } else {
                    rightOperand = parent -> rightOperand
                }
                switch(parent -> operator){
                    case '+':   leftOperand = leftOperand + rightOperand
                                break
                    case '-':   leftOperand = leftOperand - rightOperand
                                break
                    case '*':   leftOperand = leftOperand * rightOperand
                                break
                    case '/':   leftOperand = leftOperand / rightOperand
                                break
                }
            }

Topic-5
Write a program to maintain a priority queue using a binary search tree

    Insertion In BST:
        Input(s):
            1.  Root node of tree
            2.  Key to be inserted
        Output(s):
            1.  Updated binary search tree
        Complexity:
            Best case -> O(logn)
            Average case -> O(logn)
            Worst case -> O(n)
        Algorithm:
            search(rootNode, key){
                currElem = rootNode
                while(currElem != NULL){
                    if((key < currElem -> key) && (currElem -> leftSubTree != NULL && currElem -> leftSubTree -> key != key)) {
                        currElem = currElem -> leftSubTree
                    } else if((key > currElem -> key) && (currElem -> rightSubTree != NULL && currElem -> rightSubTree -> key != key)){
                        currElem = currElem -> rightSubTree
                    } else {
                        break
                    }
                }
            }
            insert(rootNode, key){
                prevElem = search(rootNode, key)
                currElem -> key = key
                currElem -> leftSubTree = NULL
                if(prevElem == NULL){
                    rootNode = currElem
                } else if(prevElem -> key < key && prevElem -> rightSubTree == NULL){
                    prevElem -> rightSubTree = currElem
                } else if(prevElem -> key > key && prevElem -> leftSubTree == NULL){
                    prevElem -> leftSubTree = currElem
                } else {
                    //print that element already exists
                    free(currElem)
                }
            }
    Deletion In BST:
        Input(s):
            1.  Root node of tree
            2.  Key to be deleted
        Output(s):
            1.  Updated binary search tree
        Complexity:
            Best case -> O(logn)
            Average case -> O(logn)
            Worst case -> O(n)
        Algorithms:
            search(rootNode, key){
                currElem = rootNode
                while(currElem != NULL){
                    if((key < currElem -> key) && (currElem -> leftSubTree != NULL && currElem -> leftSubTree -> key != key)) {
                        currElem = currElem -> leftSubTree
                    } else if((key > currElem -> key) && (currElem -> rightSubTree != NULL && currElem -> rightSubTree -> key != key)){
                        currElem = currElem -> rightSubTree
                    } else {
                        break
                    }
                }
            }
            delete(rootNode, key){
                q = search(rootNode, key)
                if(key < q -> key){
                    p = q -> leftSubTree
                } else {
                    p = q -> rightSubTree
                }
                if(p -> leftSubTree == NULL){
                    r = p -> rightSubTree
                } else if(p -> rightSubTree == NULL){
                    r = p -> leftSubTree
                } else {
                    f = p
                    r = p -> rightSubTree
                    s = r -> leftSubTree
                    while(s != NULL){
                        f = r
                        r = s
                        s = s -> leftSubTree
                    }
                    q = f
                    p = r
                }
                if(p -> key < q -> key){
                    q -> leftSubTree = r
                } else {
                    q -> rightSubTree = r
                }
                free(p)
            }
